#!/usr/bin/env python3

"""calendly_openapi - Generated CLI for Calendly’s API is [REST](http://en.wikipedia.org/wiki/Representational_State_Transfer)-based and has predictable resource-oriented URLs. It uses **JSON** for request and response bodies and standard HTTP methods, authentication, and response codes.<br> ##### OAuth 2.0 To access Calendly data through the API, you can authenticate with **personal access tokens** or **OAuth 2.0**. To learn more about these authentication methods and when and how to use them, see [Getting Started with the Calendly API](https://developer.calendly.com/getting-started).

Auto-generated by openapi2cli. Do not edit manually.
"""

import json
import os
import sys
from typing import Optional

import click
import requests

try:
    from rich.console import Console
    from rich.table import Table
    RICH_AVAILABLE = True
except ImportError:
    RICH_AVAILABLE = False


# Configuration
BASE_URL = "https://api.calendly.com"
ENV_PREFIX = "CALENDLY_OPENAPI"


def get_auth_headers(api_key: Optional[str] = None, token: Optional[str] = None) -> dict:
    """Get authentication headers."""
    headers = {}

    # Try CLI args first, then env vars
    key = api_key or os.environ.get(ENV_PREFIX + "_API_KEY")
    tok = token or os.environ.get(ENV_PREFIX + "_TOKEN")

    if tok:
        headers["Authorization"] = "Bearer " + tok
    elif key:
        headers["X-API-Key"] = key

    return headers


def format_output(data, output_format: str):
    """Format output based on requested format."""
    if output_format == "json":
        click.echo(json.dumps(data, indent=2))
    elif output_format == "raw":
        click.echo(data)
    elif output_format == "table" and RICH_AVAILABLE:
        console = Console()
        if isinstance(data, list) and data:
            table = Table()
            first = data[0]
            if isinstance(first, dict):
                for key in first.keys():
                    table.add_column(str(key))
                for item in data:
                    if isinstance(item, dict):
                        table.add_row(*[str(v) for v in item.values()])
            else:
                table.add_column("value")
                for item in data:
                    table.add_row(str(item))
            console.print(table)
        elif isinstance(data, dict):
            table = Table()
            table.add_column("Key")
            table.add_column("Value")
            for k, v in data.items():
                table.add_row(str(k), str(v))
            console.print(table)
        else:
            console.print(data)
    else:
        click.echo(json.dumps(data, indent=2))


def make_request(
    method: str,
    path: str,
    base_url: str,
    params: dict = None,
    json_data: dict = None,
    headers: dict = None,
    path_params: dict = None,
):
    """Make an HTTP request to the API."""
    if path_params:
        for key, value in path_params.items():
            path = path.replace("{" + key + "}", str(value))

    url = base_url.rstrip("/") + path

    try:
        response = requests.request(
            method=method,
            url=url,
            params=params,
            json=json_data,
            headers=headers,
            timeout=30,
        )
        response.raise_for_status()

        try:
            return response.json()
        except json.JSONDecodeError:
            return response.text

    except requests.exceptions.RequestException as e:
        click.echo("Error: " + str(e), err=True)
        sys.exit(1)


@click.group()
@click.option("--output", "-o", default="json", help="Output format (json, table, raw)")
@click.option("--base-url", default=BASE_URL, help="API base URL")
@click.option("--api-key", envvar=ENV_PREFIX + "_API_KEY", help="API key")
@click.option("--token", envvar=ENV_PREFIX + "_TOKEN", help="Bearer token")
@click.version_option(version="2.0.0")
@click.pass_context
def cli(ctx, output, base_url, api_key, token):
    """Calendly’s API is [REST](http://en.wikipedia.org/wiki/Representational_State_Transfer)-based and has predictable resource-oriented URLs. It uses **JSON** for request and response bodies and standard HTTP methods, authentication, and response codes.<br> ##### OAuth 2.0 To access Calendly data through the API, you can authenticate with **personal access tokens** or **OAuth 2.0**. To learn more about these authentication methods and when and how to use them, see [Getting Started with the Calendly API](https://developer.calendly.com/getting-started)."""
    ctx.ensure_object(dict)
    ctx.obj["output"] = output
    ctx.obj["base_url"] = base_url
    ctx.obj["headers"] = get_auth_headers(api_key, token)



@cli.group()
def scheduled_events():
    """Commands for Scheduled Events"""
    pass



@scheduled_events.command("get")
@click.option("--uuid", required=True, help='uuid parameter')
@click.option("--status", help='Indicates if the invitee "canceled" or still "active"')
@click.option("--sort", default='created_at:asc', help='Order results by the **created_at** field and direction specified: ascending ("asc") or descending ("desc")')
@click.option("--email", help='Indicates if the results should be filtered by email address')
@click.option("--page-token", help='The token to pass to get the next portion of the collection')
@click.option("--count", default='20', help='The number of rows to return')
@click.pass_context
def scheduled_events_get(ctx, uuid, status, sort, email, page_token, count):
    """List Event Invitees"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid
    if status is not None:
        query_params["status"] = status
    if sort is not None:
        query_params["sort"] = sort
    if email is not None:
        query_params["email"] = email
    if page_token is not None:
        query_params["page_token"] = page_token
    if count is not None:
        query_params["count"] = count

    result = make_request(
        method="GET",
        path="/scheduled_events/{uuid}/invitees",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@scheduled_events.command("get-events")
@click.option("--user", help='Return events that are scheduled with the user associated with this URI')
@click.option("--organization", help='Return events that are scheduled with the organization associated with this URI')
@click.option("--invitee-email", help='Return events that are scheduled with the invitee associated with this email address')
@click.option("--status", help='Whether the scheduled event is `active` or `canceled`')
@click.option("--sort", help='Order results by the specified field and direction. Accepts comma-separated list of {field}:{direction} values. Supported fields are: start_time. Sort direction is specified as: asc, desc.')
@click.option("--min-start-time", help='Include events with start times after this time (sample time format: "2020-01-02T03:04:05.678Z"). This time should use the UTC timezone.')
@click.option("--max-start-time", help='Include events with start times prior to this time (sample time format: "2020-01-02T03:04:05.678Z"). This time should use the UTC timezone.')
@click.option("--page-token", help='The token to pass to get the next portion of the collection')
@click.option("--count", default='20', help='The number of rows to return')
@click.pass_context
def scheduled_events_get_events(ctx, user, organization, invitee_email, status, sort, min_start_time, max_start_time, page_token, count):
    """List Events"""
    path_params = {}
    query_params = {}
    body_data = {}
    if user is not None:
        query_params["user"] = user
    if organization is not None:
        query_params["organization"] = organization
    if invitee_email is not None:
        query_params["invitee_email"] = invitee_email
    if status is not None:
        query_params["status"] = status
    if sort is not None:
        query_params["sort"] = sort
    if min_start_time is not None:
        query_params["min_start_time"] = min_start_time
    if max_start_time is not None:
        query_params["max_start_time"] = max_start_time
    if page_token is not None:
        query_params["page_token"] = page_token
    if count is not None:
        query_params["count"] = count

    result = make_request(
        method="GET",
        path="/scheduled_events",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@scheduled_events.command("get-event_uuid-invitees-invitee_uuid")
@click.option("--event-uuid", required=True, help="The event's unique identifier")
@click.option("--invitee-uuid", required=True, help="The invitee's unique identifier")
@click.pass_context
def scheduled_events_get_event_uuid_invitees_invitee_uuid(ctx, event_uuid, invitee_uuid):
    """Get Event Invitee"""
    path_params = {}
    query_params = {}
    body_data = {}
    if event_uuid is not None:
        path_params["event_uuid"] = event_uuid
    if invitee_uuid is not None:
        path_params["invitee_uuid"] = invitee_uuid

    result = make_request(
        method="GET",
        path="/scheduled_events/{event_uuid}/invitees/{invitee_uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@scheduled_events.command("get-uuid")
@click.option("--uuid", required=True, help="The event's unique identifier")
@click.pass_context
def scheduled_events_get_uuid(ctx, uuid):
    """Get Event"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="GET",
        path="/scheduled_events/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@scheduled_events.command("get-no-show")
@click.option("--uuid", required=True, help='uuid parameter')
@click.pass_context
def scheduled_events_get_no_show(ctx, uuid):
    """Get Invitee No Show"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="GET",
        path="/invitee_no_shows/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@scheduled_events.command("delete-no-show")
@click.option("--uuid", required=True, help='uuid parameter')
@click.pass_context
def scheduled_events_delete_no_show(ctx, uuid):
    """Delete Invitee No Show"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="DELETE",
        path="/invitee_no_shows/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@scheduled_events.command("post-invitee-no-show")
@click.option("--invitee", help='invitee field')
@click.option("--data", help='Raw JSON data for request body')
@click.pass_context
def scheduled_events_post_invitee_no_show(ctx, invitee, data):
    """Create Invitee No Show"""
    path_params = {}
    query_params = {}
    body_data = {}
    if invitee is not None:
        body_data["invitee"] = invitee
    if data is not None:
        body_data = json.loads(data)

    result = make_request(
        method="POST",
        path="/invitee_no_shows",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])



@cli.group()
def event_types():
    """Commands for Event Types"""
    pass



@event_types.command("get-types")
@click.option("--active", help='Return only active event types if true, only inactive if false, or all event types if this parameter is omitted.')
@click.option("--organization", help="View available personal, team, and organization event types associated with the organization's URI.")
@click.option("--user", help="View available personal, team, and organization event types associated with the user's URI.")
@click.option("--sort", default='name:asc', help='Order results by the specified field and direction. Accepts comma-separated list of {field}:{direction} values. Supported fields are: name. Sort direction is specified as: asc, desc.')
@click.option("--page-token", help='The token to pass to get the next portion of the collection')
@click.option("--count", default='20', help='The number of rows to return')
@click.pass_context
def event_types_get_types(ctx, active, organization, user, sort, page_token, count):
    """List User's Event Types"""
    path_params = {}
    query_params = {}
    body_data = {}
    if active is not None:
        query_params["active"] = active
    if organization is not None:
        query_params["organization"] = organization
    if user is not None:
        query_params["user"] = user
    if sort is not None:
        query_params["sort"] = sort
    if page_token is not None:
        query_params["page_token"] = page_token
    if count is not None:
        query_params["count"] = count

    result = make_request(
        method="GET",
        path="/event_types",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@event_types.command("get-uuid")
@click.option("--uuid", required=True, help='uuid parameter')
@click.pass_context
def event_types_get_uuid(ctx, uuid):
    """Get Event Type"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="GET",
        path="/event_types/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])



@cli.group()
def users():
    """Commands for Users"""
    pass



@users.command("get")
@click.option("--uuid", required=True, help='User unique identifier, or the constant "me" to reference the caller')
@click.pass_context
def users_get(ctx, uuid):
    """Get user"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="GET",
        path="/users/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@users.command("get-user-account")
@click.pass_context
def users_get_user_account(ctx):
    """Get current user"""
    path_params = {}
    query_params = {}
    body_data = {}

    result = make_request(
        method="GET",
        path="/users/me",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])



@cli.group()
def organizations():
    """Commands for Organizations"""
    pass



@organizations.command("get-uuid-invitations")
@click.option("--uuid", required=True, help="The organization's unique identifier")
@click.option("--count", default='20', help='The number of rows to return')
@click.option("--page-token", help='The token to pass to get the next portion of the collection')
@click.option("--sort", default='created_at:asc', help='Order results by the field name and direction specified (ascending or descending). Returns multiple sets of results in a comma-separated list.')
@click.option("--email", help='Indicates if the results should be filtered by email address')
@click.option("--status", help='Indicates if the results should be filtered by status ("pending", "accepted", or "declined")')
@click.pass_context
def organizations_get_uuid_invitations(ctx, uuid, count, page_token, sort, email, status):
    """List Organization Invitations"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid
    if count is not None:
        query_params["count"] = count
    if page_token is not None:
        query_params["page_token"] = page_token
    if sort is not None:
        query_params["sort"] = sort
    if email is not None:
        query_params["email"] = email
    if status is not None:
        query_params["status"] = status

    result = make_request(
        method="GET",
        path="/organizations/{uuid}/invitations",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@organizations.command("post-organizations-uuid-invitations")
@click.option("--uuid", required=True, help="The organization's unique identifier")
@click.option("--email", required=True, help='The email of the user being invited')
@click.option("--data", help='Raw JSON data for request body')
@click.pass_context
def organizations_post_organizations_uuid_invitations(ctx, uuid, email, data):
    """Invite User to Organization"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid
    if email is not None:
        body_data["email"] = email
    if data is not None:
        body_data = json.loads(data)

    result = make_request(
        method="POST",
        path="/organizations/{uuid}/invitations",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@organizations.command("revoke-users-organization-invitation")
@click.option("--org-uuid", required=True, help='The organization’s unique identifier')
@click.option("--uuid", required=True, help="The organization invitation's unique identifier")
@click.pass_context
def organizations_revoke_users_organization_invitation(ctx, org_uuid, uuid):
    """Revoke User's Organization Invitation"""
    path_params = {}
    query_params = {}
    body_data = {}
    if org_uuid is not None:
        path_params["org_uuid"] = org_uuid
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="DELETE",
        path="/organizations/{org_uuid}/invitations/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@organizations.command("get-org_uuid-invitations-uuid")
@click.option("--org-uuid", required=True, help='The organization’s unique identifier')
@click.option("--uuid", required=True, help="The organization invitation's unique identifier")
@click.pass_context
def organizations_get_org_uuid_invitations_uuid(ctx, org_uuid, uuid):
    """Get Organization Invitation"""
    path_params = {}
    query_params = {}
    body_data = {}
    if org_uuid is not None:
        path_params["org_uuid"] = org_uuid
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="GET",
        path="/organizations/{org_uuid}/invitations/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@organizations.command("get-uuid-memberships")
@click.option("--uuid", required=True, help="The organization membership's unique identifier")
@click.pass_context
def organizations_get_uuid_memberships(ctx, uuid):
    """Get Organization Membership"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="GET",
        path="/organization_memberships/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@organizations.command("delete-uuid-memberships")
@click.option("--uuid", required=True, help="The organization membership's unique identifier")
@click.pass_context
def organizations_delete_uuid_memberships(ctx, uuid):
    """Remove User from Organization"""
    path_params = {}
    query_params = {}
    body_data = {}
    if uuid is not None:
        path_params["uuid"] = uuid

    result = make_request(
        method="DELETE",
        path="/organization_memberships/{uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@organizations.command("get-memberships")
@click.option("--page-token", help='The token to pass to get the next portion of the collection')
@click.option("--count", default='20', help='The number of rows to return')
@click.option("--email", help='Indicates if the results should be filtered by email address')
@click.option("--organization", help='Indicates if the results should be filtered by organization')
@click.option("--user", help='Indicates if the results should be filtered by user')
@click.pass_context
def organizations_get_memberships(ctx, page_token, count, email, organization, user):
    """List Organization Memberships"""
    path_params = {}
    query_params = {}
    body_data = {}
    if page_token is not None:
        query_params["page_token"] = page_token
    if count is not None:
        query_params["count"] = count
    if email is not None:
        query_params["email"] = email
    if organization is not None:
        query_params["organization"] = organization
    if user is not None:
        query_params["user"] = user

    result = make_request(
        method="GET",
        path="/organization_memberships",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])



@cli.group()
def webhooks():
    """Commands for Webhooks"""
    pass



@webhooks.command("post-users-uuid-webhooks")
@click.option("--url", required=True, help='The URL where you want to receive POST requests for events you are subscribed to.')
@click.option("--events", required=True, help='List of user events to subscribe to.')
@click.option("--organization", required=True, help='The unique reference to the organization that the webhook will be tied to.')
@click.option("--user", help='The unique reference to the user that the webhook will be tied to.')
@click.option("--scope", required=True, help='Indicates if the webhook subscription scope will be "organization" or "user"')
@click.option("--signing-key", help='Optional secret key shared between your application and Calendly. See https://developer.calendly.com/api-docs/ZG9jOjM2MzE2MDM4-webhook-signatures for additional information.')
@click.option("--data", help='Raw JSON data for request body')
@click.pass_context
def webhooks_post_users_uuid_webhooks(ctx, url, events, organization, user, scope, signing_key, data):
    """Create Webhook Subscription"""
    path_params = {}
    query_params = {}
    body_data = {}
    if url is not None:
        body_data["url"] = url
    if events is not None:
        body_data["events"] = events
    if organization is not None:
        body_data["organization"] = organization
    if user is not None:
        body_data["user"] = user
    if scope is not None:
        body_data["scope"] = scope
    if signing_key is not None:
        body_data["signing_key"] = signing_key
    if data is not None:
        body_data = json.loads(data)

    result = make_request(
        method="POST",
        path="/webhook_subscriptions",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@webhooks.command("get")
@click.option("--organization", required=True, help='Indicates if the results should be filtered by organization')
@click.option("--user", help='Indicates if the results should be filtered by user. This parameter is only required if the `scope` parameter is set to `user`.')
@click.option("--page-token", help='The token to pass to get the next portion of the collection')
@click.option("--count", default='20', help='The number of rows to return')
@click.option("--sort", help='Order results by the specified field and direction. Accepts comma-separated list of {field}:{direction} values. Supported fields are: created_at. Sort direction is specified as: asc, desc.')
@click.option("--scope", required=True, help='Filter the list by organization or user')
@click.pass_context
def webhooks_get(ctx, organization, user, page_token, count, sort, scope):
    """List Webhook Subscriptions"""
    path_params = {}
    query_params = {}
    body_data = {}
    if organization is not None:
        query_params["organization"] = organization
    if user is not None:
        query_params["user"] = user
    if page_token is not None:
        query_params["page_token"] = page_token
    if count is not None:
        query_params["count"] = count
    if sort is not None:
        query_params["sort"] = sort
    if scope is not None:
        query_params["scope"] = scope

    result = make_request(
        method="GET",
        path="/webhook_subscriptions",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@webhooks.command("get-user_uuid-webhooks-webhook_uuid")
@click.option("--webhook-uuid", required=True, help='webhook_uuid parameter')
@click.pass_context
def webhooks_get_user_uuid_webhooks_webhook_uuid(ctx, webhook_uuid):
    """Get Webhook Subscription"""
    path_params = {}
    query_params = {}
    body_data = {}
    if webhook_uuid is not None:
        path_params["webhook_uuid"] = webhook_uuid

    result = make_request(
        method="GET",
        path="/webhook_subscriptions/{webhook_uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])


@webhooks.command("delete-user_uuid-webhooks-webhook_uuid")
@click.option("--webhook-uuid", required=True, help='webhook_uuid parameter')
@click.pass_context
def webhooks_delete_user_uuid_webhooks_webhook_uuid(ctx, webhook_uuid):
    """Delete Webhook Subscription"""
    path_params = {}
    query_params = {}
    body_data = {}
    if webhook_uuid is not None:
        path_params["webhook_uuid"] = webhook_uuid

    result = make_request(
        method="DELETE",
        path="/webhook_subscriptions/{webhook_uuid}",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])



@cli.group()
def scheduling_links():
    """Commands for Scheduling Links"""
    pass



@scheduling_links.command("post-scheduling_links")
@click.option("--max-event-count", required=True, help='The max number of events that can be scheduled using this scheduling link.')
@click.option("--owner", required=True, help='A link to the resource that owns this Scheduling Link (currently, this is always an Event Type)')
@click.option("--owner-type", required=True, help='Resource type (currently, this is always EventType)')
@click.option("--data", help='Raw JSON data for request body')
@click.pass_context
def scheduling_links_post_scheduling_links(ctx, max_event_count, owner, owner_type, data):
    """Create Single-Use Scheduling Link"""
    path_params = {}
    query_params = {}
    body_data = {}
    if max_event_count is not None:
        body_data["max_event_count"] = max_event_count
    if owner is not None:
        body_data["owner"] = owner
    if owner_type is not None:
        body_data["owner_type"] = owner_type
    if data is not None:
        body_data = json.loads(data)

    result = make_request(
        method="POST",
        path="/scheduling_links",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])



@cli.group()
def data_compliance():
    """Commands for Data Compliance"""
    pass



@data_compliance.command("post-data-compliance-deletion-invitees")
@click.option("--emails", required=True, help='emails field')
@click.option("--data", help='Raw JSON data for request body')
@click.pass_context
def data_compliance_post_data_compliance_deletion_invitees(ctx, emails, data):
    """Delete Invitee Data"""
    path_params = {}
    query_params = {}
    body_data = {}
    if emails is not None:
        body_data["emails"] = emails
    if data is not None:
        body_data = json.loads(data)

    result = make_request(
        method="POST",
        path="/data_compliance/deletion/invitees",
        base_url=ctx.obj["base_url"],
        params=query_params or None,
        json_data=body_data or None,
        headers=ctx.obj["headers"],
        path_params=path_params or None,
    )

    format_output(result, ctx.obj["output"])




def main():
    """Main entry point."""
    cli()


if __name__ == "__main__":
    main()